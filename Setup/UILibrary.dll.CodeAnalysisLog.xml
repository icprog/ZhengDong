<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="c:\program files (x86)\microsoft visual studio 14.0\team tools\static analysis tools\fxcop\Xml\CodeAnalysisReport.xsl"?>
<FxCopReport Version="14.0">
 <Targets>
  <Target Name="C:\Users\Administrator\Desktop\zhengdong\Setup\UILibrary.dll">
   <Modules>
    <Module Name="uilibrary.dll">
     <Namespaces>
      <Namespace Name="UILibrary">
       <Types>
        <Type Name="ImageDc" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'ImageDc' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DisposableTypesShouldDeclareFinalizer" Category="Microsoft.Usage" CheckId="CA2216" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="ImageDc.cs" Line="59">针对 'ImageDc' 实现终结器或析构函数。</Issue>
            </Message>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="ImageDc.cs" Line="59">修改 'ImageDc.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="InterpolationModeGraphics" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'InterpolationModeGraphics' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="InterpolationModeGraphics.cs" Line="24">修改 'InterpolationModeGraphics.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MaskControlBase" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#.ctor(System.IntPtr)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="MaskControlBase.cs" Line="12">'MaskControlBase.MaskControlBase(IntPtr)' 调入具有 LinkDemand 的 'NativeWindow.NativeWindow()'。通过此调用，'NativeWindow.NativeWindow()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'MaskControlBase.MaskControlBase(IntPtr)'&#xD;&#xA;   -&gt;'MaskControlBase.MaskControlBase(IntPtr)'&#xD;&#xA;   -&gt;'ScrollBarManager.ScrollBarMaskControl.ScrollBarMaskControl(ScrollBarManager)'&#xD;&#xA;   -&gt;'ScrollBarManager.CreateHandle()'&#xD;&#xA;   -&gt;'ScrollBarManager.ScrollBarManager(ScrollBar)'&#xD;&#xA;   -&gt;'SkinVScrollBar.OnHandleCreated(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DestroyHandleInternal()" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="MaskControlBase.cs" Line="78">'MaskControlBase.DestroyHandleInternal()' 调入具有 LinkDemand 的 'NativeWindow.DestroyHandle()'。通过此调用，'NativeWindow.DestroyHandle()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'MaskControlBase.DestroyHandleInternal()'&#xD;&#xA;   -&gt;'MaskControlBase.DestroyHandleInternal()'&#xD;&#xA;   -&gt;'MaskControlBase.Dispose(bool)'&#xD;&#xA;   -&gt;'MaskControlBase.Dispose()'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose(bool)'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose()'&#xD;&#xA;   -&gt;'SkinVScrollBar.Dispose(bool)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="MaskControlBase.cs" Line="78">'MaskControlBase.DestroyHandleInternal()' 调入具有 LinkDemand 的 'NativeWindow.DestroyHandle()'。通过此调用，'NativeWindow.DestroyHandle()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'MaskControlBase.DestroyHandleInternal()'&#xD;&#xA;   -&gt;'MaskControlBase.DestroyHandleInternal()'&#xD;&#xA;   -&gt;'MaskControlBase.Dispose(bool)'&#xD;&#xA;   -&gt;'MaskControlBase.Dispose()'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose(bool)'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose()'&#xD;&#xA;   -&gt;'SkinVScrollBar.OnHandleCreated(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#IsHandleCreated" Kind="Property" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Accessors>
            <Accessor Name="#get_IsHandleCreated()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
             <Messages>
              <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
               <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="MaskControlBase.cs" Line="172">'MaskControlBase.IsHandleCreated.get()' 调入具有 LinkDemand 的 'NativeWindow.Handle.get()'。通过此调用，'NativeWindow.Handle.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'MaskControlBase.IsHandleCreated.get()'&#xD;&#xA;   -&gt;'MaskControlBase.IsHandleCreated.get()'&#xD;&#xA;   -&gt;'MaskControlBase.DestroyHandleInternal()'&#xD;&#xA;   -&gt;'MaskControlBase.Dispose(bool)'&#xD;&#xA;   -&gt;'MaskControlBase.Dispose()'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose(bool)'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose()'&#xD;&#xA;   -&gt;'SkinVScrollBar.Dispose(bool)'</Issue>
               <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="MaskControlBase.cs" Line="172">'MaskControlBase.IsHandleCreated.get()' 调入具有 LinkDemand 的 'NativeWindow.Handle.get()'。通过此调用，'NativeWindow.Handle.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'MaskControlBase.IsHandleCreated.get()'&#xD;&#xA;   -&gt;'MaskControlBase.IsHandleCreated.get()'&#xD;&#xA;   -&gt;'MaskControlBase.DestroyHandleInternal()'&#xD;&#xA;   -&gt;'MaskControlBase.Dispose(bool)'&#xD;&#xA;   -&gt;'MaskControlBase.Dispose()'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose(bool)'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose()'&#xD;&#xA;   -&gt;'SkinVScrollBar.OnHandleCreated(EventArgs)'</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#OnCreateHandle()" Kind="Method" Static="False" Accessibility="FamilyOrAssembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="MaskControlBase.cs" Line="110">'MaskControlBase.OnCreateHandle()' 调入具有 LinkDemand 的 'NativeWindow.CreateHandle(CreateParams)'。通过此调用，'NativeWindow.CreateHandle(CreateParams)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'MaskControlBase.OnCreateHandle()'&#xD;&#xA;   -&gt;'MaskControlBase.OnCreateHandle()'&#xD;&#xA;   -&gt;'ScrollBarManager.CreateHandle()'&#xD;&#xA;   -&gt;'ScrollBarManager.ScrollBarManager(ScrollBar)'&#xD;&#xA;   -&gt;'SkinVScrollBar.OnHandleCreated(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetZorder()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="MaskControlBase.cs" Line="138">'MaskControlBase.SetZorder()' 调入具有 LinkDemand 的 'NativeWindow.Handle.get()'。通过此调用，'NativeWindow.Handle.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'MaskControlBase.SetZorder()'&#xD;&#xA;   -&gt;'MaskControlBase.SetZorder()'&#xD;&#xA;   -&gt;'MaskControlBase.OnCreateHandle()'&#xD;&#xA;   -&gt;'ScrollBarManager.CreateHandle()'&#xD;&#xA;   -&gt;'ScrollBarManager.ScrollBarManager(ScrollBar)'&#xD;&#xA;   -&gt;'SkinVScrollBar.OnHandleCreated(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NevigateTabControl" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#CreateParams" Kind="Property" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_CreateParams()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
               <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="NevigateTabControl.cs" Line="235">'NevigateTabControl.CreateParams.get()' 调入具有 LinkDemand 的 'TabControl.CreateParams.get()'。通过此调用，'TabControl.CreateParams.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NevigateTabControl.CreateParams.get()'&#xD;&#xA;   -&gt;'NevigateTabControl.CreateParams.get()'</Issue>
              </Message>
              <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
               <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="NevigateTabControl.cs" Line="235">向 'NevigateTabControl.CreateParams.get()' 添加下列安全特性以匹配基方法 'TabControl.CreateParams.get()' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#WndProc(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="NevigateTabControl.cs" Line="246">'NevigateTabControl.WndProc(ref Message)' 调入具有 LinkDemand 的 'Message.Msg.get()'。通过此调用，'Message.Msg.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NevigateTabControl.WndProc(ref Message)'&#xD;&#xA;   -&gt;'NevigateTabControl.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="NevigateTabControl.cs" Line="246">'NevigateTabControl.WndProc(ref Message)' 调入具有 LinkDemand 的 'TabControl.WndProc(ref Message)'。通过此调用，'TabControl.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NevigateTabControl.WndProc(ref Message)'&#xD;&#xA;   -&gt;'NevigateTabControl.WndProc(ref Message)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="NevigateTabControl.cs" Line="246">向 'NevigateTabControl.WndProc(ref Message)' 添加下列安全特性以匹配基方法 'TabControl.WndProc(ref Message)' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CloseTabEventHandler" Kind="Event" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DeclareEventHandlersCorrectly" Category="Microsoft.Design" CheckId="CA1009" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="First" Certainty="95" Level="Error">将 'Action&lt;int&gt;' 的第一个参数声明为一个名为“sender”的对象。</Issue>
             <Issue Name="Second" Certainty="95" Level="Error">将 'Action&lt;int&gt;' 的第二个参数声明为 EventArgs，或者声明为扩展 EventArgs 的类型的名为“e”的实例。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ProfessionalToolStripRendererEx" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#DrawDottedGrip(System.Drawing.Graphics,System.Drawing.Rectangle,System.Boolean,System.Boolean,System.Drawing.Color,System.Drawing.Color)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="ProfessionalToolStripRendererEx.cs" Line="41">'ProfessionalToolStripRendererEx.DrawDottedGrip(Graphics, Rectangle, bool, bool, Color, Color)' 调入具有 LinkDemand 的 'Graphics.GetHdc()'。通过此调用，'Graphics.GetHdc()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'ProfessionalToolStripRendererEx.DrawDottedGrip(Graphics, Rectangle, bool, bool, Color, Color)'&#xD;&#xA;   -&gt;'ProfessionalToolStripRendererEx.DrawDottedGrip(Graphics, Rectangle, bool, bool, Color, Color)'&#xD;&#xA;   -&gt;'ProfessionalToolStripRendererEx.OnRenderGrip(ToolStripGripRenderEventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetPixel(System.IntPtr,System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'ProfessionalToolStripRendererEx.SetPixel(IntPtr, int, int, int)'。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ScrollBarManager" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#.ctor(System.Windows.Forms.ScrollBar)" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="ScrollBarManager.cs" Line="17">'ScrollBarManager.ScrollBarManager(ScrollBar)' 调入具有 LinkDemand 的 'NativeWindow.NativeWindow()'。通过此调用，'NativeWindow.NativeWindow()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'ScrollBarManager.ScrollBarManager(ScrollBar)'&#xD;&#xA;   -&gt;'ScrollBarManager.ScrollBarManager(ScrollBar)'&#xD;&#xA;   -&gt;'SkinVScrollBar.OnHandleCreated(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateHandle()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="ScrollBarManager.cs" Line="54">'ScrollBarManager.CreateHandle()' 调入具有 LinkDemand 的 'NativeWindow.AssignHandle(IntPtr)'。通过此调用，'NativeWindow.AssignHandle(IntPtr)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'ScrollBarManager.CreateHandle()'&#xD;&#xA;   -&gt;'ScrollBarManager.CreateHandle()'&#xD;&#xA;   -&gt;'ScrollBarManager.ScrollBarManager(ScrollBar)'&#xD;&#xA;   -&gt;'SkinVScrollBar.OnHandleCreated(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ReleaseHandleInternal()" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="ScrollBarManager.cs" Line="305">'ScrollBarManager.ReleaseHandleInternal()' 调入具有 LinkDemand 的 'NativeWindow.Handle.get()'。通过此调用，'NativeWindow.Handle.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'ScrollBarManager.ReleaseHandleInternal()'&#xD;&#xA;   -&gt;'ScrollBarManager.ReleaseHandleInternal()'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose(bool)'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose()'&#xD;&#xA;   -&gt;'SkinVScrollBar.Dispose(bool)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="ScrollBarManager.cs" Line="305">'ScrollBarManager.ReleaseHandleInternal()' 调入具有 LinkDemand 的 'NativeWindow.Handle.get()'。通过此调用，'NativeWindow.Handle.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'ScrollBarManager.ReleaseHandleInternal()'&#xD;&#xA;   -&gt;'ScrollBarManager.ReleaseHandleInternal()'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose(bool)'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose()'&#xD;&#xA;   -&gt;'SkinVScrollBar.OnHandleCreated(EventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="ScrollBarManager.cs" Line="305">'ScrollBarManager.ReleaseHandleInternal()' 调入具有 LinkDemand 的 'NativeWindow.ReleaseHandle()'。通过此调用，'NativeWindow.ReleaseHandle()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'ScrollBarManager.ReleaseHandleInternal()'&#xD;&#xA;   -&gt;'ScrollBarManager.ReleaseHandleInternal()'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose(bool)'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose()'&#xD;&#xA;   -&gt;'SkinVScrollBar.Dispose(bool)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="ScrollBarManager.cs" Line="305">'ScrollBarManager.ReleaseHandleInternal()' 调入具有 LinkDemand 的 'NativeWindow.ReleaseHandle()'。通过此调用，'NativeWindow.ReleaseHandle()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'ScrollBarManager.ReleaseHandleInternal()'&#xD;&#xA;   -&gt;'ScrollBarManager.ReleaseHandleInternal()'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose(bool)'&#xD;&#xA;   -&gt;'ScrollBarManager.Dispose()'&#xD;&#xA;   -&gt;'SkinVScrollBar.OnHandleCreated(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SkinComboBox" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetComboBoxInfo()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="40">'SkinComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxButtonPressed()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonPressed.get()'&#xD;&#xA;   -&gt;'SkinComboBox.RenderComboBox(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="40">'SkinComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonState.set(ControlState)'&#xD;&#xA;   -&gt;'SkinComboBox.OnMouseEnter(EventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="40">'SkinComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonState.set(ControlState)'&#xD;&#xA;   -&gt;'SkinComboBox.OnMouseLeave(EventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="40">'SkinComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonState.set(ControlState)'&#xD;&#xA;   -&gt;'SkinComboBox.OnMouseMove(MouseEventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="40">'SkinComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonState.set(ControlState)'&#xD;&#xA;   -&gt;'SkinComboBox.OnMouseUp(MouseEventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="40">'SkinComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'SkinComboBox.OnMouseEnter(EventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="40">'SkinComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'SkinComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'SkinComboBox.OnMouseMove(MouseEventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="40">'SkinComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'SkinComboBox.OnCreateControl()'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OnHandleCreated(System.EventArgs)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="90">'SkinComboBox.OnHandleCreated(EventArgs)' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.OnHandleCreated(EventArgs)'&#xD;&#xA;   -&gt;'SkinComboBox.OnHandleCreated(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RenderComboBox(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="176">'SkinComboBox.RenderComboBox(ref Message)' 调入具有 LinkDemand 的 'Message.HWnd.get()'。通过此调用，'Message.HWnd.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.RenderComboBox(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.RenderComboBox(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WndProc(ref Message)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WmPaint(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="255">'SkinComboBox.WmPaint(ref Message)' 调入具有 LinkDemand 的 'ComboBox.WndProc(ref Message)'。通过此调用，'ComboBox.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="255">'SkinComboBox.WmPaint(ref Message)' 调入具有 LinkDemand 的 'Message.HWnd.get()'。通过此调用，'Message.HWnd.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="255">'SkinComboBox.WmPaint(ref Message)' 调入具有 LinkDemand 的 'Message.Result.set(IntPtr)'。通过此调用，'Message.Result.set(IntPtr)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WndProc(ref Message)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WndProc(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="285">'SkinComboBox.WndProc(ref Message)' 调入具有 LinkDemand 的 'ComboBox.WndProc(ref Message)'。通过此调用，'ComboBox.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.WndProc(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="285">'SkinComboBox.WndProc(ref Message)' 调入具有 LinkDemand 的 'Message.Msg.get()'。通过此调用，'Message.Msg.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.WndProc(ref Message)'&#xD;&#xA;   -&gt;'SkinComboBox.WndProc(ref Message)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="285">向 'SkinComboBox.WndProc(ref Message)' 添加下列安全特性以匹配基方法 'ComboBox.WndProc(ref Message)' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SkinComboBox+EditNativeWindow" Kind="Class" Accessibility="Private" ExternallyVisible="False">
         <Members>
          <Member Name="#.ctor(UILibrary.SkinComboBox)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="513">'SkinComboBox.EditNativeWindow.EditNativeWindow(SkinComboBox)' 调入具有 LinkDemand 的 'NativeWindow.AssignHandle(IntPtr)'。通过此调用，'NativeWindow.AssignHandle(IntPtr)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.EditNativeWindow.EditNativeWindow(SkinComboBox)'&#xD;&#xA;   -&gt;'SkinComboBox.EditNativeWindow.EditNativeWindow(SkinComboBox)'&#xD;&#xA;   -&gt;'SkinComboBox.OnHandleCreated(EventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="513">'SkinComboBox.EditNativeWindow.EditNativeWindow(SkinComboBox)' 调入具有 LinkDemand 的 'NativeWindow.NativeWindow()'。通过此调用，'NativeWindow.NativeWindow()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.EditNativeWindow.EditNativeWindow(SkinComboBox)'&#xD;&#xA;   -&gt;'SkinComboBox.EditNativeWindow.EditNativeWindow(SkinComboBox)'&#xD;&#xA;   -&gt;'SkinComboBox.OnHandleCreated(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinComboBox.cs" Line="520">'SkinComboBox.EditNativeWindow.Dispose()' 调入具有 LinkDemand 的 'NativeWindow.ReleaseHandle()'。通过此调用，'NativeWindow.ReleaseHandle()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinComboBox.EditNativeWindow.Dispose()'&#xD;&#xA;   -&gt;'SkinComboBox.EditNativeWindow.Dispose()'&#xD;&#xA;   -&gt;'SkinComboBox.OnHandleDestroyed(EventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetDC(System.IntPtr)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'SkinComboBox.EditNativeWindow.GetDC(IntPtr)'。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ReleaseDC(System.IntPtr,System.IntPtr)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="95" Level="CriticalWarning">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 'SkinComboBox.EditNativeWindow.ReleaseDC(IntPtr, IntPtr)'。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SkinTabControl" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#CreateParams" Kind="Property" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_CreateParams()" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
               <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinTabControl.cs" Line="539">'SkinTabControl.CreateParams.get()' 调入具有 LinkDemand 的 'TabControl.CreateParams.get()'。通过此调用，'TabControl.CreateParams.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinTabControl.CreateParams.get()'&#xD;&#xA;   -&gt;'SkinTabControl.CreateParams.get()'</Issue>
              </Message>
              <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
               <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinTabControl.cs" Line="539">向 'SkinTabControl.CreateParams.get()' 添加下列安全特性以匹配基方法 'TabControl.CreateParams.get()' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#WndProc(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinTabControl.cs" Line="464">'SkinTabControl.WndProc(ref Message)' 调入具有 LinkDemand 的 'Message.Msg.get()'。通过此调用，'Message.Msg.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinTabControl.WndProc(ref Message)'&#xD;&#xA;   -&gt;'SkinTabControl.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinTabControl.cs" Line="464">'SkinTabControl.WndProc(ref Message)' 调入具有 LinkDemand 的 'TabControl.WndProc(ref Message)'。通过此调用，'TabControl.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'SkinTabControl.WndProc(ref Message)'&#xD;&#xA;   -&gt;'SkinTabControl.WndProc(ref Message)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SkinTabControl.cs" Line="464">向 'SkinTabControl.WndProc(ref Message)' 添加下列安全特性以匹配基方法 'TabControl.WndProc(ref Message)' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CloseTabEventHandler" Kind="Event" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DeclareEventHandlersCorrectly" Category="Microsoft.Design" CheckId="CA1009" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="First" Certainty="95" Level="Error">将 'Action&lt;int&gt;' 的第一个参数声明为一个名为“sender”的对象。</Issue>
             <Issue Name="Second" Certainty="95" Level="Error">将 'Action&lt;int&gt;' 的第二个参数声明为 EventArgs，或者声明为扩展 EventArgs 的类型的名为“e”的实例。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="SmoothingModeGraphics" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'SmoothingModeGraphics' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="SmoothingModeGraphics.cs" Line="24">修改 'SmoothingModeGraphics.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TCComboBox" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetComboBoxInfo()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="182">'TCComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonState.set(ControlState)'&#xD;&#xA;   -&gt;'TCComboBox.OnMouseDown(MouseEventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="182">'TCComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonState.set(ControlState)'&#xD;&#xA;   -&gt;'TCComboBox.OnMouseEnter(EventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="182">'TCComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonState.set(ControlState)'&#xD;&#xA;   -&gt;'TCComboBox.OnMouseLeave(EventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="182">'TCComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonState.set(ControlState)'&#xD;&#xA;   -&gt;'TCComboBox.OnMouseMove(MouseEventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="182">'TCComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonState.set(ControlState)'&#xD;&#xA;   -&gt;'TCComboBox.OnMouseUp(MouseEventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="182">'TCComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'TCComboBox.EditRect.get()'&#xD;&#xA;   -&gt;'TCComboBox.RenderComboBox(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="182">'TCComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'TCComboBox.OnMouseEnter(EventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="182">'TCComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetDropDownButtonRect()'&#xD;&#xA;   -&gt;'TCComboBox.ButtonRect.get()'&#xD;&#xA;   -&gt;'TCComboBox.OnMouseMove(MouseEventArgs)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="182">'TCComboBox.GetComboBoxInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.GetComboBoxInfo()'&#xD;&#xA;   -&gt;'TCComboBox.OnCreateControl()'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RenderComboBox(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="287">'TCComboBox.RenderComboBox(ref Message)' 调入具有 LinkDemand 的 'Message.HWnd.get()'。通过此调用，'Message.HWnd.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.RenderComboBox(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.RenderComboBox(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WndProc(ref Message)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WmPaint(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="251">'TCComboBox.WmPaint(ref Message)' 调入具有 LinkDemand 的 'ComboBox.WndProc(ref Message)'。通过此调用，'ComboBox.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="251">'TCComboBox.WmPaint(ref Message)' 调入具有 LinkDemand 的 'Message.HWnd.get()'。通过此调用，'Message.HWnd.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="251">'TCComboBox.WmPaint(ref Message)' 调入具有 LinkDemand 的 'Message.Result.set(IntPtr)'。通过此调用，'Message.Result.set(IntPtr)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WmPaint(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WndProc(ref Message)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WndProc(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="239">'TCComboBox.WndProc(ref Message)' 调入具有 LinkDemand 的 'ComboBox.WndProc(ref Message)'。通过此调用，'ComboBox.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.WndProc(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="239">'TCComboBox.WndProc(ref Message)' 调入具有 LinkDemand 的 'Message.Msg.get()'。通过此调用，'Message.Msg.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCComboBox.WndProc(ref Message)'&#xD;&#xA;   -&gt;'TCComboBox.WndProc(ref Message)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCComboBox.cs" Line="239">向 'TCComboBox.WndProc(ref Message)' 添加下列安全特性以匹配基方法 'ComboBox.WndProc(ref Message)' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TCWatermarkText" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#WndProc(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCWatermarkText.cs" Line="43">'TCWatermarkText.WndProc(ref Message)' 调入具有 LinkDemand 的 'Message.Msg.get()'。通过此调用，'Message.Msg.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCWatermarkText.WndProc(ref Message)'&#xD;&#xA;   -&gt;'TCWatermarkText.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCWatermarkText.cs" Line="43">'TCWatermarkText.WndProc(ref Message)' 调入具有 LinkDemand 的 'TextBox.WndProc(ref Message)'。通过此调用，'TextBox.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCWatermarkText.WndProc(ref Message)'&#xD;&#xA;   -&gt;'TCWatermarkText.WndProc(ref Message)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCWatermarkText.cs" Line="43">向 'TCWatermarkText.WndProc(ref Message)' 添加下列安全特性以匹配基方法 'TextBox.WndProc(ref Message)' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TCWebBrowser" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCWebBrowser.Designer.cs" Line="8">'TCWebBrowser.TCWebBrowser()' 调入具有 LinkDemand 的 'WebBrowser.WebBrowser()'。通过此调用，'WebBrowser.WebBrowser()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCWebBrowser.TCWebBrowser()'&#xD;&#xA;   -&gt;'TCWebBrowser.TCWebBrowser()'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#.ctor(System.ComponentModel.IContainer)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCWebBrowser.Designer.cs" Line="8">'TCWebBrowser.TCWebBrowser(IContainer)' 调入具有 LinkDemand 的 'WebBrowser.WebBrowser()'。通过此调用，'WebBrowser.WebBrowser()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCWebBrowser.TCWebBrowser(IContainer)'&#xD;&#xA;   -&gt;'TCWebBrowser.TCWebBrowser(IContainer)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Dispose(System.Boolean)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCWebBrowser.Designer.cs" Line="15">'TCWebBrowser.Dispose(bool)' 调入具有 LinkDemand 的 'WebBrowser.Dispose(bool)'。通过此调用，'WebBrowser.Dispose(bool)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TCWebBrowser.Dispose(bool)'&#xD;&#xA;   -&gt;'TCWebBrowser.Dispose(bool)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="TCWebBrowser.Designer.cs" Line="15">向 'TCWebBrowser.Dispose(bool)' 添加下列安全特性以匹配基方法 'WebBrowser.Dispose(bool)' 上的 LinkDemand: [PermissionSet(SecurityAction.LinkDemand, Name = "FullTrust")]。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="UpdateForm" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#BothAlpha(System.Drawing.Bitmap,System.Boolean,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="UpdateForm.cs" Line="14">'UpdateForm.BothAlpha(Bitmap, bool, bool)' 调入具有 LinkDemand 的 'Bitmap.LockBits(Rectangle, ImageLockMode, PixelFormat)'。通过此调用，'Bitmap.LockBits(Rectangle, ImageLockMode, PixelFormat)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'UpdateForm.BothAlpha(Bitmap, bool, bool)'&#xD;&#xA;   -&gt;'UpdateForm.BothAlpha(Bitmap, bool, bool)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="UpdateForm.cs" Line="14">'UpdateForm.BothAlpha(Bitmap, bool, bool)' 调入具有 LinkDemand 的 'Bitmap.UnlockBits(BitmapData)'。通过此调用，'Bitmap.UnlockBits(BitmapData)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'UpdateForm.BothAlpha(Bitmap, bool, bool)'&#xD;&#xA;   -&gt;'UpdateForm.BothAlpha(Bitmap, bool, bool)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="UpdateForm.cs" Line="14">'UpdateForm.BothAlpha(Bitmap, bool, bool)' 调入具有 LinkDemand 的 'Marshal.Copy(IntPtr, byte[], int, int)'。通过此调用，'Marshal.Copy(IntPtr, byte[], int, int)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'UpdateForm.BothAlpha(Bitmap, bool, bool)'&#xD;&#xA;   -&gt;'UpdateForm.BothAlpha(Bitmap, bool, bool)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="UpdateForm.cs" Line="14">'UpdateForm.BothAlpha(Bitmap, bool, bool)' 调入具有 LinkDemand 的 'Marshal.Copy(byte[], int, IntPtr, int)'。通过此调用，'Marshal.Copy(byte[], int, IntPtr, int)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'UpdateForm.BothAlpha(Bitmap, bool, bool)'&#xD;&#xA;   -&gt;'UpdateForm.BothAlpha(Bitmap, bool, bool)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GaryImg(System.Drawing.Bitmap)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="UpdateForm.cs" Line="207">'UpdateForm.GaryImg(Bitmap)' 调入具有 LinkDemand 的 'Bitmap.LockBits(Rectangle, ImageLockMode, PixelFormat)'。通过此调用，'Bitmap.LockBits(Rectangle, ImageLockMode, PixelFormat)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'UpdateForm.GaryImg(Bitmap)'&#xD;&#xA;   -&gt;'UpdateForm.GaryImg(Bitmap)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="UpdateForm.cs" Line="207">'UpdateForm.GaryImg(Bitmap)' 调入具有 LinkDemand 的 'Bitmap.UnlockBits(BitmapData)'。通过此调用，'Bitmap.UnlockBits(BitmapData)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'UpdateForm.GaryImg(Bitmap)'&#xD;&#xA;   -&gt;'UpdateForm.GaryImg(Bitmap)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="UpdateForm.cs" Line="207">'UpdateForm.GaryImg(Bitmap)' 调入具有 LinkDemand 的 'Marshal.Copy(IntPtr, byte[], int, int)'。通过此调用，'Marshal.Copy(IntPtr, byte[], int, int)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'UpdateForm.GaryImg(Bitmap)'&#xD;&#xA;   -&gt;'UpdateForm.GaryImg(Bitmap)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary" File="UpdateForm.cs" Line="207">'UpdateForm.GaryImg(Bitmap)' 调入具有 LinkDemand 的 'Marshal.Copy(byte[], int, IntPtr, int)'。通过此调用，'Marshal.Copy(byte[], int, IntPtr, int)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'UpdateForm.GaryImg(Bitmap)'&#xD;&#xA;   -&gt;'UpdateForm.GaryImg(Bitmap)'</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="UILibrary.CheckBoxComboBox">
       <Types>
        <Type Name="CheckBoxComboBoxListControl" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#WndProc(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\CheckBoxComboBox" File="CheckBoxComboBox.cs" Line="309">'CheckBoxComboBoxListControl.WndProc(ref Message)' 调入具有 LinkDemand 的 'Popup.ProcessResizing(ref Message)'。通过此调用，'Popup.ProcessResizing(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'CheckBoxComboBoxListControl.WndProc(ref Message)'&#xD;&#xA;   -&gt;'CheckBoxComboBoxListControl.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\CheckBoxComboBox" File="CheckBoxComboBox.cs" Line="309">'CheckBoxComboBoxListControl.WndProc(ref Message)' 调入具有 LinkDemand 的 'ScrollableControl.WndProc(ref Message)'。通过此调用，'ScrollableControl.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'CheckBoxComboBoxListControl.WndProc(ref Message)'&#xD;&#xA;   -&gt;'CheckBoxComboBoxListControl.WndProc(ref Message)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\CheckBoxComboBox" File="CheckBoxComboBox.cs" Line="309">向 'CheckBoxComboBoxListControl.WndProc(ref Message)' 添加下列安全特性以匹配基方法 'ScrollableControl.WndProc(ref Message)' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="CheckBoxComboBoxListControlContainer" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#WndProc(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\CheckBoxComboBox" File="CheckBoxComboBox.cs" Line="252">'CheckBoxComboBoxListControlContainer.WndProc(ref Message)' 调入具有 LinkDemand 的 'Popup.ProcessResizing(ref Message)'。通过此调用，'Popup.ProcessResizing(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'CheckBoxComboBoxListControlContainer.WndProc(ref Message)'&#xD;&#xA;   -&gt;'CheckBoxComboBoxListControlContainer.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\CheckBoxComboBox" File="CheckBoxComboBox.cs" Line="252">'CheckBoxComboBoxListControlContainer.WndProc(ref Message)' 调入具有 LinkDemand 的 'UserControl.WndProc(ref Message)'。通过此调用，'UserControl.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'CheckBoxComboBoxListControlContainer.WndProc(ref Message)'&#xD;&#xA;   -&gt;'CheckBoxComboBoxListControlContainer.WndProc(ref Message)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\CheckBoxComboBox" File="CheckBoxComboBox.cs" Line="252">向 'CheckBoxComboBoxListControlContainer.WndProc(ref Message)' 添加下列安全特性以匹配基方法 'UserControl.WndProc(ref Message)' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="ObjectSelectionWrapper`1" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Name" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Name()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
               <Issue Name="PropertyGetter" Certainty="90" Level="Warning" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\CheckBoxComboBox\Selection Wrappers" File="ObjectSelectionWrapper.cs" Line="91">'ObjectSelectionWrapper&lt;T&gt;.Name.get()' 创建 'Exception' 类型的异常，该异常类型不应当在属性中引发。如果有可能会引发此异常实例，请使用其他异常类型，将该属性转换为方法，或者更改该属性的逻辑，使它不再引发异常。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="Popup" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ProcessDialogKey(System.Windows.Forms.Keys)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\CheckBoxComboBox" File="Popup.cs" Line="191">'Popup.ProcessDialogKey(Keys)' 调入具有 LinkDemand 的 'ToolStripDropDown.ProcessDialogKey(Keys)'。通过此调用，'ToolStripDropDown.ProcessDialogKey(Keys)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'Popup.ProcessDialogKey(Keys)'&#xD;&#xA;   -&gt;'Popup.ProcessDialogKey(Keys)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\CheckBoxComboBox" File="Popup.cs" Line="191">向 'Popup.ProcessDialogKey(Keys)' 添加下列安全特性以匹配基方法 'ToolStripDropDown.ProcessDialogKey(Keys)' 上的 LinkDemand: [UIPermission(SecurityAction.LinkDemand, Window = UIPermissionWindow.AllWindows)]。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="UILibrary.MultiColumnComboBox">
       <Types>
        <Type Name="CCBColumnCollection" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Item[System.String]" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Item(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
               <Issue Name="PropertyGetter" Certainty="90" Level="Warning" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\MultiColumnComboBox" File="MultiColumnComboBox.cs" Line="795">'CCBColumnCollection.this.get(string)' 创建 'Exception' 类型的异常，该异常类型不应当在属性中引发。如果有可能会引发此异常实例，请使用其他异常类型，将该属性转换为方法，或者更改该属性的逻辑，使它不再引发异常。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="MultiColumnComboBox" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Item[System.String]" Kind="Property" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Item(System.String)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
               <Issue Name="PropertyGetter" Certainty="90" Level="Warning" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\MultiColumnComboBox" File="MultiColumnComboBox.cs" Line="525">'MultiColumnComboBox.this.get(string)' 创建 'Exception' 类型的异常，该异常类型不应当在属性中引发。如果有可能会引发此异常实例，请使用其他异常类型，将该属性转换为方法，或者更改该属性的逻辑，使它不再引发异常。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="UILibrary.Properties">
       <Types>
        <Type Name="Resources" Kind="Class" Accessibility="Assembly" ExternallyVisible="False">
         <Members>
          <Member Name="#.ctor()" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="AvoidUncalledPrivateCode" Category="Microsoft.Performance" CheckId="CA1811" Status="ExcludedInSource" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking" LastSeen="0001-01-01 00:00:00Z" />
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="UILibrary.PushPanel">
       <Types>
        <Type Name="ImageDc" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'ImageDc' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DisposableTypesShouldDeclareFinalizer" Category="Microsoft.Usage" CheckId="CA2216" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="ImageDc.cs" Line="94">针对 'ImageDc' 实现终结器或析构函数。</Issue>
            </Message>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="ImageDc.cs" Line="94">修改 'ImageDc.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="InterpolationModeGraphics" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'InterpolationModeGraphics' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="InterpolationModeGraphics.cs" Line="37">修改 'InterpolationModeGraphics.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NCPanel" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#GetWindowInfo()" Kind="Method" Static="False" Accessibility="Assembly" ExternallyVisible="False">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="342">'NCPanel.GetWindowInfo()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.GetWindowInfo()'&#xD;&#xA;   -&gt;'NCPanel.GetWindowInfo()'&#xD;&#xA;   -&gt;'NCPanel.OnPaintBackground(PaintEventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OnPaintBackground(System.Windows.Forms.PaintEventArgs)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="137">'NCPanel.OnPaintBackground(PaintEventArgs)' 调入具有 LinkDemand 的 'Graphics.GetHdc()'。通过此调用，'Graphics.GetHdc()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.OnPaintBackground(PaintEventArgs)'&#xD;&#xA;   -&gt;'NCPanel.OnPaintBackground(PaintEventArgs)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WmNcCalcSize(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="221">'NCPanel.WmNcCalcSize(ref Message)' 调入具有 LinkDemand 的 'Marshal.StructureToPtr(object, IntPtr, bool)'。通过此调用，'Marshal.StructureToPtr(object, IntPtr, bool)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'&#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="221">'NCPanel.WmNcCalcSize(ref Message)' 调入具有 LinkDemand 的 'Message.GetLParam(Type)'。通过此调用，'Message.GetLParam(Type)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'&#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="221">'NCPanel.WmNcCalcSize(ref Message)' 调入具有 LinkDemand 的 'Message.LParam.get()'。通过此调用，'Message.LParam.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'&#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="221">'NCPanel.WmNcCalcSize(ref Message)' 调入具有 LinkDemand 的 'Message.Result.set(IntPtr)'。通过此调用，'Message.Result.set(IntPtr)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'&#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="221">'NCPanel.WmNcCalcSize(ref Message)' 调入具有 LinkDemand 的 'Message.WParam.get()'。通过此调用，'Message.WParam.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'&#xD;&#xA;   -&gt;'NCPanel.WmNcCalcSize(ref Message)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WmNcPaint(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="245">'NCPanel.WmNcPaint(ref Message)' 调入具有 LinkDemand 的 'Message.HWnd.get()'。通过此调用，'Message.HWnd.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.WmNcPaint(ref Message)'&#xD;&#xA;   -&gt;'NCPanel.WmNcPaint(ref Message)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WndProc(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="115">'NCPanel.WndProc(ref Message)' 调入具有 LinkDemand 的 'Message.Msg.get()'。通过此调用，'Message.Msg.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.WndProc(ref Message)'&#xD;&#xA;   -&gt;'NCPanel.WndProc(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="115">'NCPanel.WndProc(ref Message)' 调入具有 LinkDemand 的 'ScrollableControl.WndProc(ref Message)'。通过此调用，'ScrollableControl.WndProc(ref Message)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'NCPanel.WndProc(ref Message)'&#xD;&#xA;   -&gt;'NCPanel.WndProc(ref Message)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="NCPanel.cs" Line="115">向 'NCPanel.WndProc(ref Message)' 添加下列安全特性以匹配基方法 'ScrollableControl.WndProc(ref Message)' 上的 LinkDemand: [SecurityPermission(SecurityAction.LinkDemand, Flags = SecurityPermissionFlag.UnmanagedCode)]。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PushPanel+PushPanelItemCollection" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#System.Collections.ICollection.CopyTo(System.Array,System.Int32)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="PushPanel.cs" Line="567">将 'PushPanel.PushPanelItemCollection' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'ICollection.CopyTo(Array, int)' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.ICollection.IsSynchronized" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.ICollection.get_IsSynchronized()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="PushPanel.cs" Line="578">将 'PushPanel.PushPanelItemCollection' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'ICollection.IsSynchronized.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.ICollection.SyncRoot" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.ICollection.get_SyncRoot()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="PushPanel.cs" Line="583">将 'PushPanel.PushPanelItemCollection' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'ICollection.SyncRoot.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.IList.Insert(System.Int32,System.Object)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Messages>
            <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="PushPanel.cs" Line="519">将 'PushPanel.PushPanelItemCollection' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IList.Insert(int, object)' 的功能且对派生类可见的新方法。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#System.Collections.IList.IsFixedSize" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.IList.get_IsFixedSize()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="PushPanel.cs" Line="529">将 'PushPanel.PushPanelItemCollection' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IList.IsFixedSize.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.IList.IsReadOnly" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.IList.get_IsReadOnly()" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="PushPanel.cs" Line="534">将 'PushPanel.PushPanelItemCollection' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IList.IsReadOnly.get()' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
          <Member Name="#System.Collections.IList.Item[System.Int32]" Kind="Property" Static="False" Accessibility="Private" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#System.Collections.IList.set_Item(System.Int32,System.Object)" Kind="Method" Static="False" Accessibility="Private" ExternallyVisible="True">
             <Messages>
              <Message TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
               <Issue Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="PushPanel.cs" Line="558">将 'PushPanel.PushPanelItemCollection' 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 'IList.this.set(int, object)' 的功能且对派生类可见的新方法。</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="SmoothingModeGraphics" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'SmoothingModeGraphics' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\PushPanel" File="SmoothingModeGraphics.cs" Line="36">修改 'SmoothingModeGraphics.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="UILibrary.TCEventArgs">
       <Types>
        <Type Name="PaintScrollBarArrowEventArgs" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'PaintScrollBarArrowEventArgs' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\TCEventArgs" File="PaintScrollBarArrowEventArgs.cs" Line="31">修改 'PaintScrollBarArrowEventArgs.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PaintScrollBarThumbEventArgs" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'PaintScrollBarThumbEventArgs' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\TCEventArgs" File="PaintScrollBarThumbEventArgs.cs" Line="29">修改 'PaintScrollBarThumbEventArgs.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PaintScrollBarTrackEventArgs" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Messages>
          <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
           <Issue Name="ProvideDisposeBool" Certainty="95" Level="Error">对 'PaintScrollBarTrackEventArgs' 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Issue>
          </Message>
         </Messages>
         <Members>
          <Member Name="#Dispose()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="DisposeImplementation" Certainty="95" Level="Error" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\TCEventArgs" File="PaintScrollBarTrackEventArgs.cs" Line="27">修改 'PaintScrollBarTrackEventArgs.Dispose()'，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="UILibrary.UserDropDownControl">
       <Types>
        <Type Name="UserInfoControl" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ProcessDialogKey(System.Windows.Forms.Keys)" Kind="Method" Static="False" Accessibility="Family" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\UserDropDownControl" File="UserInfoControl.cs" Line="57">'UserInfoControl.ProcessDialogKey(Keys)' 调入具有 LinkDemand 的 'ContainerControl.ProcessDialogKey(Keys)'。通过此调用，'ContainerControl.ProcessDialogKey(Keys)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'UserInfoControl.ProcessDialogKey(Keys)'&#xD;&#xA;   -&gt;'UserInfoControl.ProcessDialogKey(Keys)'</Issue>
            </Message>
            <Message TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="BaseOnly" Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\UserDropDownControl" File="UserInfoControl.cs" Line="57">向 'UserInfoControl.ProcessDialogKey(Keys)' 添加下列安全特性以匹配基方法 'ContainerControl.ProcessDialogKey(Keys)' 上的 LinkDemand: [UIPermission(SecurityAction.LinkDemand, Window = UIPermissionWindow.AllWindows)]。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="UILibrary.Win32">
       <Types>
        <Type Name="FORMATETC" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ptd" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'FORMATETC.ptd' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="Helper" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#ToIntPtr(System.Object)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32" File="Helper.cs" Line="82">'Helper.ToIntPtr(object)' 调入具有 LinkDemand 的 'Marshal.AllocCoTaskMem(int)'。通过此调用，'Marshal.AllocCoTaskMem(int)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'Helper.ToIntPtr(object)'&#xD;&#xA;   -&gt;'Helper.ToIntPtr(object)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32" File="Helper.cs" Line="82">'Helper.ToIntPtr(object)' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'Helper.ToIntPtr(object)'&#xD;&#xA;   -&gt;'Helper.ToIntPtr(object)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32" File="Helper.cs" Line="82">'Helper.ToIntPtr(object)' 调入具有 LinkDemand 的 'Marshal.StructureToPtr(object, IntPtr, bool)'。通过此调用，'Marshal.StructureToPtr(object, IntPtr, bool)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'Helper.ToIntPtr(object)'&#xD;&#xA;   -&gt;'Helper.ToIntPtr(object)'</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NativeMethods" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#AdjustWindowRectEx(UILibrary.Win32.Struct.RECT&amp;,System.Int32,System.Boolean,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.AdjustWindowRectEx(ref RECT, int, bool, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AlphaBlend(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,UILibrary.Win32.NativeMethods+BLENDFUNCTION)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.AlphaBlend(IntPtr, int, int, int, int, IntPtr, int, int, int, int, NativeMethods.BLENDFUNCTION)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#AnimateWindow(System.IntPtr,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.AnimateWindow(IntPtr, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BeginPaint(System.IntPtr,UILibrary.Win32.Struct.PAINTSTRUCT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.BeginPaint(IntPtr, ref PAINTSTRUCT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#BitBlt(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.BitBlt(IntPtr, int, int, int, int, IntPtr, int, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CallNextHookEx(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CallNextHookEx(IntPtr, int, IntPtr, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ChildWindowFromPointEx(System.IntPtr,UILibrary.Win32.NativeMethods+Point,System.UInt32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="1" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.ChildWindowFromPointEx(IntPtr, NativeMethods.Point, uint)' 的参数 'pt' 在 32 位 平台上的字节宽度将为 8。这是不正确的，因为此 API 的实际本机声明表明该参数在 32 位 平台上的字节宽度应为 4。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'NativeMethods.Point'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.ChildWindowFromPointEx(IntPtr, NativeMethods.Point, uint)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CombineRgn(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CombineRgn(IntPtr, IntPtr, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateCompatibleBitmap(System.IntPtr,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CreateCompatibleBitmap(IntPtr, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateCompatibleDC(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CreateCompatibleDC(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateDC(System.String,System.String,System.String,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="3" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.CreateDC(string, string, string, int)' 的参数 'lpInitData' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CreateDC(string, string, string, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszDriver' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszDevice' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="2" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszOutput' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateDCA(System.String,System.String,System.String,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CreateDCA(string, string, string, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszDriver' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszDevice' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="2" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszOutput' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateDCW(System.String,System.String,System.String,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="3" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.CreateDCW(string, string, string, int)' 的参数 'lpInitData' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CreateDCW(string, string, string, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateILockBytesOnHGlobal(System.IntPtr,System.Boolean,UILibrary.Win32.ILockBytes&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CreateILockBytesOnHGlobal(IntPtr, bool, out ILockBytes)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateRectRgn(System.Int32,System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CreateRectRgn(int, int, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateRoundRectRgn(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.CreateRoundRectRgn(int, int, int, int, int, int)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CreateRoundRectRgn(int, int, int, int, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#CreateWindowEx(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.CreateWindowEx(int, string, string, int, int, int, int, int, IntPtr, IntPtr, IntPtr, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DefWindowProc(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.DefWindowProc(IntPtr, int, IntPtr, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DeleteDC(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.DeleteDC(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DeleteObject(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.DeleteObject(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DestroyIcon(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.DestroyIcon(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DestroyWindow(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.DestroyWindow(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DisableProcessWindowsGhosting()" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.DisableProcessWindowsGhosting()' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#DrawIconEx(System.IntPtr,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.DrawIconEx(IntPtr, int, int, IntPtr, int, int, int, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EnableScrollBar(System.IntPtr,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.EnableScrollBar(IntPtr, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EndPaint(System.IntPtr,UILibrary.Win32.Struct.PAINTSTRUCT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.EndPaint(IntPtr, ref PAINTSTRUCT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#EqualRect(UILibrary.Win32.Struct.RECT&amp;,UILibrary.Win32.Struct.RECT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.EqualRect(ref RECT, ref RECT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ExcludeClipRect(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.ExcludeClipRect(IntPtr, int, int, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FindExecutable(System.String,System.String,System.String&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.FindExecutable(string, string, ref string)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.FindExecutable(string, string, ref string)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="Parameter" Certainty="75" Level="Error">为了降低安全风险，请将参数 'filename' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode 或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或与系统相关的编码，请设置 BestFitMapping=false；为了提高安全性，还可以设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="Parameter" Certainty="75" Level="Error">为了降低安全风险，请将参数 'directory' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode 或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或与系统相关的编码，请设置 BestFitMapping=false；为了提高安全性，还可以设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FindWindow(System.String,System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.FindWindow(string, string)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpClassName' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpWindowName' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FindWindowEx(System.IntPtr,System.IntPtr,System.String,System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.FindWindowEx(IntPtr, IntPtr, string, string)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="2" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszClass' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="3" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpszWindow' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#FlashWindow(System.IntPtr,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.FlashWindow(IntPtr, bool)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetCaretBlinkTime()" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetCaretBlinkTime()' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetClassLongPtr32(System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.GetClassLongPtr32(IntPtr, int)' 的返回类型在 64 位 平台上的字节宽度将为 8。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 4。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'IntPtr'。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetClassLongPtr64(System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Private" ExternallyVisible="False">
           <Messages>
            <Message TypeName="PInvokeEntryPointsShouldExist" Category="Microsoft.Interoperability" CheckId="CA1400" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="CriticalWarning">更正 'NativeMethods.GetClassLongPtr64(IntPtr, int)' 的声明，使它正确地指向 'user32.dll' 中的现有入口点。当前链接到的非托管入口点的名称是 GetClassLongPtr。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetClientRect(System.IntPtr,UILibrary.Win32.Struct.RECT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetClientRect(IntPtr, ref RECT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetComboBoxInfo(System.IntPtr,UILibrary.Win32.NativeMethods+ComboBoxInfo&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetComboBoxInfo(IntPtr, ref NativeMethods.ComboBoxInfo)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetCurrentThreadId()" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetCurrentThreadId()' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetCursorInfo(UILibrary.Win32.NativeMethods+PCURSORINFO&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetCursorInfo(out NativeMethods.PCURSORINFO)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetCursorPos(UILibrary.Win32.NativeMethods+Point&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetCursorPos(ref NativeMethods.Point)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetDC(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetDC(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetDCEx(System.IntPtr,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetDCEx(IntPtr, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetDesktopWindow()" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetDesktopWindow()' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetKeyState(System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetKeyState(int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetParent(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetParent(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetScrollBarInfo(System.IntPtr,System.UInt32,UILibrary.Win32.Struct.SCROLLBARINFO&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetScrollBarInfo(IntPtr, uint, ref SCROLLBARINFO)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetScrollInfo(System.IntPtr,System.Int32,UILibrary.Win32.Struct.SCROLLINFO&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetScrollInfo(IntPtr, int, ref SCROLLINFO)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetSystemMenu(System.IntPtr,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetSystemMenu(IntPtr, bool)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetSystemMetrics(System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetSystemMetrics(int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetWindowDC(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetWindowDC(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetWindowInfo(System.IntPtr,UILibrary.Win32.Struct.WINDOWINFO&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetWindowInfo(IntPtr, ref WINDOWINFO)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetWindowLong(System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetWindowLong(IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetWindowLong(System.Runtime.InteropServices.HandleRef,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetWindowLong(HandleRef, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetWindowLongPtr(System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokeEntryPointsShouldExist" Category="Microsoft.Interoperability" CheckId="CA1400" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="CriticalWarning">更正 'NativeMethods.GetWindowLongPtr(IntPtr, int)' 的声明，使它正确地指向 'user32.dll' 中的现有入口点。当前链接到的非托管入口点的名称是 GetWindowLongPtr。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetWindowLongPtr(IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetWindowPlacement(System.IntPtr,UILibrary.Win32.Struct.WINDOWPLACEMENT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetWindowPlacement(IntPtr, ref WINDOWPLACEMENT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#GetWindowRect(System.IntPtr,UILibrary.Win32.Struct.RECT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.GetWindowRect(IntPtr, ref RECT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InitCommonControlsEx(UILibrary.Win32.Struct.INITCOMMONCONTROLSEX&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.InitCommonControlsEx(ref INITCOMMONCONTROLSEX)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#InvalidateRect(System.IntPtr,UILibrary.Win32.Struct.RECT&amp;,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.InvalidateRect(IntPtr, ref RECT, bool)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#IsAppThemed()" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.IsAppThemed()' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#IsWindowVisible(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.IsWindowVisible(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#IsZoomed(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.IsZoomed(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#KillTimer(System.IntPtr,System.UInt32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.KillTimer(IntPtr, uint)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LoadCursorFromFile(System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.LoadCursorFromFile(string)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'fileName' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LoadIcon(System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="1" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.LoadIcon(IntPtr, int)' 的参数 'lpIconName' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.LoadIcon(IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LockWindowUpdate(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.LockWindowUpdate(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#MessageBeep(System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.MessageBeep(int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#mouse_event(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="4" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.mouse_event(int, int, int, int, int)' 的参数 'dwExtraInfo' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.mouse_event(int, int, int, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#MulDiv(System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.MulDiv(int, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OffsetRect(UILibrary.Win32.Struct.RECT&amp;,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.OffsetRect(ref RECT, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OleCreateFromFile(System.Guid&amp;,System.String,System.Guid&amp;,System.UInt32,UILibrary.Win32.FORMATETC&amp;,UILibrary.Win32.IOleClientSite,UILibrary.Win32.IStorage,System.Object&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.OleCreateFromFile(ref Guid, string, ref Guid, uint, ref FORMATETC, IOleClientSite, IStorage, out object)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#OleSetContainedObject(System.Object,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.OleSetContainedObject(object, bool)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PostMessage(System.IntPtr,System.Int32,System.IntPtr,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.PostMessage(IntPtr, int, IntPtr, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#PtInRect(UILibrary.Win32.Struct.RECT&amp;,UILibrary.Win32.NativeMethods+Point)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.PtInRect(ref RECT, NativeMethods.Point)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RedrawWindow(System.IntPtr,System.IntPtr,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.RedrawWindow(IntPtr, IntPtr, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RedrawWindow(System.IntPtr,UILibrary.Win32.Struct.RECT&amp;,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.RedrawWindow(IntPtr, ref RECT, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ReleaseCapture()" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.ReleaseCapture()' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ReleaseDC(System.IntPtr,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.ReleaseDC(IntPtr, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RtlMoveMemory(System.IntPtr,UILibrary.Win32.Struct.NMTTDISPINFO&amp;,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.RtlMoveMemory(IntPtr, ref NMTTDISPINFO, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RtlMoveMemory(UILibrary.Win32.Struct.NMCUSTOMDRAW&amp;,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.RtlMoveMemory(ref NMCUSTOMDRAW, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RtlMoveMemory(UILibrary.Win32.Struct.NMHDR&amp;,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.RtlMoveMemory(ref NMHDR, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RtlMoveMemory(UILibrary.Win32.Struct.NMTTCUSTOMDRAW&amp;,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.RtlMoveMemory(ref NMTTCUSTOMDRAW, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RtlMoveMemory(UILibrary.Win32.Struct.NMTTDISPINFO&amp;,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.RtlMoveMemory(ref NMTTDISPINFO, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#RtlMoveMemory(UILibrary.Win32.Struct.POINT&amp;,UILibrary.Win32.Struct.RECT&amp;,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.RtlMoveMemory(ref POINT, ref RECT, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ScreenToClient(System.IntPtr,UILibrary.Win32.NativeMethods+Point&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.ScreenToClient(IntPtr, ref NativeMethods.Point)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SelectObject(System.IntPtr,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SelectObject(IntPtr, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendMessage(System.IntPtr,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendMessage(System.IntPtr,System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="2" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, int)' 的参数 'wParam' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message Id="3" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, int)' 的参数 'lParam' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, int)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendMessage(System.IntPtr,System.Int32,System.Int32,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="2" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, IntPtr)' 的参数 'wParam' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, IntPtr)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendMessage(System.IntPtr,System.Int32,System.Int32,UILibrary.Win32.Struct.RECT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="2" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, ref RECT)' 的参数 'wParam' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, ref RECT)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, ref RECT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendMessage(System.IntPtr,System.Int32,System.Int32,UILibrary.Win32.Struct.SCROLLBARINFO&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="2" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, ref SCROLLBARINFO)' 的参数 'wParam' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, ref SCROLLBARINFO)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, ref SCROLLBARINFO)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendMessage(System.IntPtr,System.Int32,System.Int32,UILibrary.Win32.Struct.TOOLINFO&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="2" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, ref TOOLINFO)' 的参数 'wParam' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, ref TOOLINFO)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SendMessage(IntPtr, int, int, ref TOOLINFO)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendMessage(System.IntPtr,System.Int32,System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="3" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, IntPtr, int)' 的参数 'lParam' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, IntPtr, int)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SendMessage(IntPtr, int, IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendMessage(System.IntPtr,System.Int32,System.IntPtr,System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, IntPtr, string)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SendMessage(IntPtr, int, IntPtr, string)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="3" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lParam' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SendMessage(System.IntPtr,System.Int32,System.IntPtr,UILibrary.Win32.Struct.NMHDR&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SendMessage(IntPtr, int, IntPtr, ref NMHDR)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SendMessage(IntPtr, int, IntPtr, ref NMHDR)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetCursorPos(System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetCursorPos(int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetFocus(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetFocus(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetPixel(System.IntPtr,System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetPixel(IntPtr, int, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetTimer(System.IntPtr,System.Int32,System.UInt32,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetTimer(IntPtr, int, uint, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetWindowLong(System.IntPtr,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetWindowLong(IntPtr, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetWindowLong(System.Runtime.InteropServices.HandleRef,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SetWindowLong(HandleRef, int, int)' 的返回类型在 64 位 平台上的字节宽度将为 8。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 4。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'IntPtr'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetWindowLong(HandleRef, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetWindowLongPtr(System.IntPtr,System.Int32,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokeEntryPointsShouldExist" Category="Microsoft.Interoperability" CheckId="CA1400" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="50" Level="CriticalWarning">更正 'NativeMethods.SetWindowLongPtr(IntPtr, int, IntPtr)' 的声明，使它正确地指向 'user32.dll' 中的现有入口点。当前链接到的非托管入口点的名称是 SetWindowLongPtr。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetWindowLongPtr(IntPtr, int, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetWindowPlacement(System.IntPtr,UILibrary.Win32.Struct.WINDOWPLACEMENT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetWindowPlacement(IntPtr, ref WINDOWPLACEMENT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetWindowPos(System.IntPtr,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetWindowPos(IntPtr, IntPtr, int, int, int, int, uint)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetWindowRgn(System.IntPtr,System.Int32,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="1" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Parameter" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.SetWindowRgn(IntPtr, int, bool)' 的参数 'hRgn' 在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该参数在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetWindowRgn(IntPtr, int, bool)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetWindowRgn(System.IntPtr,System.IntPtr,System.Boolean)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetWindowRgn(IntPtr, IntPtr, bool)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetWindowsHookEx(System.Int32,UILibrary.Win32.Callback.HookProc,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetWindowsHookEx(int, HookProc, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#SetWindowTheme(System.IntPtr,System.String,System.String)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.SetWindowTheme(IntPtr, string, string)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ShellExecute(System.IntPtr,System.String,System.String,System.String,System.String,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.ShellExecute(IntPtr, string, string, string, string, int)' 的返回类型在 64 位 平台上的字节宽度将为 4。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 8。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'int'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.ShellExecute(IntPtr, string, string, string, string, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="1" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="Parameter" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpOperation' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode 或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或与系统相关的编码，请设置 BestFitMapping=false；为了提高安全性，还可以设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="2" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="Parameter" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpFile' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode 或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或与系统相关的编码，请设置 BestFitMapping=false；为了提高安全性，还可以设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="3" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="Parameter" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpParameters' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode 或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或与系统相关的编码，请设置 BestFitMapping=false；为了提高安全性，还可以设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
            <Message Id="4" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="Parameter" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpDirectory' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode 或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或与系统相关的编码，请设置 BestFitMapping=false；为了提高安全性，还可以设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ShowWindow(System.IntPtr,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.ShowWindow(IntPtr, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#StgCreateDocfileOnILockBytes(UILibrary.Win32.ILockBytes,System.UInt32,System.UInt32,UILibrary.Win32.IStorage&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.StgCreateDocfileOnILockBytes(ILockBytes, uint, uint, out IStorage)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#StretchBlt(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.StretchBlt(IntPtr, int, int, int, int, IntPtr, int, int, int, int, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#TrackMouseEvent(UILibrary.Win32.Struct.TRACKMOUSEEVENT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.TrackMouseEvent(ref TRACKMOUSEEVENT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#TrackPopupMenu(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message Id="return" TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Name="Return" Certainty="95" Level="Error">如代码中所声明的，P/Invoke 'NativeMethods.TrackPopupMenu(IntPtr, int, int, int, int, IntPtr, IntPtr)' 的返回类型在 64 位 平台上的字节宽度将为 8。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 64 位 平台上的字节宽度应为 4。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 'IntPtr'。</Issue>
            </Message>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.TrackPopupMenu(IntPtr, int, int, int, int, IntPtr, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#TrackPopupMenuEx(System.IntPtr,System.UInt32,System.Int32,System.Int32,System.IntPtr,System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.TrackPopupMenuEx(IntPtr, uint, int, int, IntPtr, IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#UnhookWindowsHookEx(System.IntPtr)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.UnhookWindowsHookEx(IntPtr)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#UpdateLayeredWindow(System.IntPtr,System.IntPtr,UILibrary.Win32.NativeMethods+Point&amp;,UILibrary.Win32.NativeMethods+Size&amp;,System.IntPtr,UILibrary.Win32.NativeMethods+Point&amp;,System.Int32,UILibrary.Win32.NativeMethods+BLENDFUNCTION&amp;,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.UpdateLayeredWindow(IntPtr, IntPtr, ref NativeMethods.Point, ref NativeMethods.Size, IntPtr, ref NativeMethods.Point, int, ref NativeMethods.BLENDFUNCTION, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ValidateRect(System.IntPtr,UILibrary.Win32.Struct.RECT&amp;)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.ValidateRect(IntPtr, ref RECT)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WinExec(System.String,System.Int32)" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="50" Level="CriticalError">更改 P/Invoke 'NativeMethods.WinExec(string, int)' 的可访问性，使它在自己的程序集外部不再是可见的。</Issue>
            </Message>
            <Message Id="0" TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Name="ParameterImplicitAnsi" Certainty="75" Level="Error">为了降低安全风险，请将参数 'lpCmdLine' 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NativeMethods+ComboBoxInfo" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hwndCombo" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NativeMethods.ComboBoxInfo.hwndCombo' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#hwndEdit" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NativeMethods.ComboBoxInfo.hwndEdit' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#hwndList" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NativeMethods.ComboBoxInfo.hwndList' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NativeMethods+PCURSORINFO" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hCursor" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NativeMethods.PCURSORINFO.hCursor' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="REOBJECT" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32" File="REOBJECT.cs" Line="10">'REOBJECT.REOBJECT()' 调入具有 LinkDemand 的 'Marshal.SizeOf(Type)'。通过此调用，'Marshal.SizeOf(Type)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'REOBJECT.REOBJECT()'&#xD;&#xA;   -&gt;'REOBJECT.REOBJECT()'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#poleobj" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'REOBJECT.poleobj' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="STGMEDIUM" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#pUnkForRelease" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'STGMEDIUM.pUnkForRelease' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#unionmember" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'STGMEDIUM.unionmember' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="UILibrary.Win32.Com">
       <Types>
        <Type Name="tagMSG" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hwnd" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'tagMSG.hwnd' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#lParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'tagMSG.lParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#wParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'tagMSG.wParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
      <Namespace Name="UILibrary.Win32.Struct">
       <Types>
        <Type Name="API_MSG" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#FromMessage(System.Windows.Forms.Message&amp;)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="API_MSG.cs" Line="22">'API_MSG.FromMessage(ref Message)' 调入具有 LinkDemand 的 'Message.HWnd.get()'。通过此调用，'Message.HWnd.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'API_MSG.FromMessage(ref Message)'&#xD;&#xA;   -&gt;'API_MSG.FromMessage(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="API_MSG.cs" Line="22">'API_MSG.FromMessage(ref Message)' 调入具有 LinkDemand 的 'Message.LParam.get()'。通过此调用，'Message.LParam.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'API_MSG.FromMessage(ref Message)'&#xD;&#xA;   -&gt;'API_MSG.FromMessage(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="API_MSG.cs" Line="22">'API_MSG.FromMessage(ref Message)' 调入具有 LinkDemand 的 'Message.Msg.get()'。通过此调用，'Message.Msg.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'API_MSG.FromMessage(ref Message)'&#xD;&#xA;   -&gt;'API_MSG.FromMessage(ref Message)'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="API_MSG.cs" Line="22">'API_MSG.FromMessage(ref Message)' 调入具有 LinkDemand 的 'Message.WParam.get()'。通过此调用，'Message.WParam.get()' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'API_MSG.FromMessage(ref Message)'&#xD;&#xA;   -&gt;'API_MSG.FromMessage(ref Message)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#Hwnd" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'API_MSG.Hwnd' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#LParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'API_MSG.LParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#ToMessage()" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="API_MSG.cs" Line="17">'API_MSG.ToMessage()' 调入具有 LinkDemand 的 'Message.HWnd.set(IntPtr)'。通过此调用，'Message.HWnd.set(IntPtr)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'API_MSG.ToMessage()'&#xD;&#xA;   -&gt;'API_MSG.ToMessage()'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="API_MSG.cs" Line="17">'API_MSG.ToMessage()' 调入具有 LinkDemand 的 'Message.LParam.set(IntPtr)'。通过此调用，'Message.LParam.set(IntPtr)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'API_MSG.ToMessage()'&#xD;&#xA;   -&gt;'API_MSG.ToMessage()'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="API_MSG.cs" Line="17">'API_MSG.ToMessage()' 调入具有 LinkDemand 的 'Message.Msg.set(int)'。通过此调用，'Message.Msg.set(int)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'API_MSG.ToMessage()'&#xD;&#xA;   -&gt;'API_MSG.ToMessage()'</Issue>
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="API_MSG.cs" Line="17">'API_MSG.ToMessage()' 调入具有 LinkDemand 的 'Message.WParam.set(IntPtr)'。通过此调用，'Message.WParam.set(IntPtr)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'API_MSG.ToMessage()'&#xD;&#xA;   -&gt;'API_MSG.ToMessage()'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#WParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'API_MSG.WParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="CWPRETSTRUCT" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hwnd" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'CWPRETSTRUCT.hwnd' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#lParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'CWPRETSTRUCT.lParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#lResult" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'CWPRETSTRUCT.lResult' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#wParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'CWPRETSTRUCT.wParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="CWPSTRUCT" Kind="Class" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hwnd" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'CWPSTRUCT.hwnd' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#lParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'CWPSTRUCT.lParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#wParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'CWPSTRUCT.wParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="INITCOMMONCONTROLSEX" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="INITCOMMONCONTROLSEX.cs" Line="12">'INITCOMMONCONTROLSEX.INITCOMMONCONTROLSEX(int)' 调入具有 LinkDemand 的 'Marshal.SizeOf(Type)'。通过此调用，'Marshal.SizeOf(Type)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'INITCOMMONCONTROLSEX.INITCOMMONCONTROLSEX(int)'&#xD;&#xA;   -&gt;'INITCOMMONCONTROLSEX.INITCOMMONCONTROLSEX(int)'</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="MOUSEHOOKSTRUCT" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#dwExtraInfo" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'MOUSEHOOKSTRUCT.dwExtraInfo' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#hwnd" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'MOUSEHOOKSTRUCT.hwnd' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NCCALCSIZE_PARAMS" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#lppos" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NCCALCSIZE_PARAMS.lppos' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NMCUSTOMDRAW" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#dwItemSpec" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NMCUSTOMDRAW.dwItemSpec' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#hdc" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NMCUSTOMDRAW.hdc' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#lItemlParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NMCUSTOMDRAW.lItemlParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NMHDR" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hwndFrom" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NMHDR.hwndFrom' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="NMTTDISPINFO" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hinst" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NMTTDISPINFO.hinst' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#lParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NMTTDISPINFO.lParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#lpszText" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NMTTDISPINFO.lpszText' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#szText" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'NMTTDISPINFO.szText' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="PAINTSTRUCT" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hdc" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'PAINTSTRUCT.hdc' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TOOLINFO" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#.ctor(System.Int32)" Kind="Method" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
             <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="TOOLINFO.cs" Line="18">'TOOLINFO.TOOLINFO(int)' 调入具有 LinkDemand 的 'Marshal.SizeOf(Type)'。通过此调用，'Marshal.SizeOf(Type)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'TOOLINFO.TOOLINFO(int)'&#xD;&#xA;   -&gt;'TOOLINFO.TOOLINFO(int)'</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#hinst" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'TOOLINFO.hinst' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#hwnd" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'TOOLINFO.hwnd' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#lParam" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'TOOLINFO.lParam' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#lpszText" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'TOOLINFO.lpszText' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#uId" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'TOOLINFO.uId' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TRACKMOUSEEVENT" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hwndTrack" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'TRACKMOUSEEVENT.hwndTrack' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="TT_HITTESTINFO" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hwnd" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'TT_HITTESTINFO.hwnd' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="WINDOWINFO" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#atomWindowType" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'WINDOWINFO.atomWindowType' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
        <Type Name="WINDOWPLACEMENT" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#Default" Kind="Property" Static="True" Accessibility="Public" ExternallyVisible="True">
           <Accessors>
            <Accessor Name="#get_Default()" Kind="Method" Static="True" Accessibility="Public" ExternallyVisible="True">
             <Messages>
              <Message TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="NonBreaking">
               <Issue Certainty="33" Level="CriticalError" Path="C:\Users\Administrator\Desktop\zhengdong\UILibrary\Win32\Struct" File="WINDOWPLACEMENT.cs" Line="19">'WINDOWPLACEMENT.Default.get()' 调入具有 LinkDemand 的 'Marshal.SizeOf(object)'。通过此调用，'Marshal.SizeOf(object)' 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: &#xD;&#xA;   -&gt;'WINDOWPLACEMENT.Default.get()'&#xD;&#xA;   -&gt;'WINDOWPLACEMENT.Default.get()'</Issue>
              </Message>
             </Messages>
            </Accessor>
           </Accessors>
          </Member>
         </Members>
        </Type>
        <Type Name="WINDOWPOS" Kind="Struct" Accessibility="Public" ExternallyVisible="True">
         <Members>
          <Member Name="#hWnd" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'WINDOWPOS.hWnd' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
          <Member Name="#hWndInsertAfter" Kind="Field" Static="False" Accessibility="Public" ExternallyVisible="True">
           <Messages>
            <Message TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111" Status="Active" Created="2018-05-07 09:12:23Z" FixCategory="Breaking">
             <Issue Certainty="75" Level="CriticalError">将 'WINDOWPOS.hWndInsertAfter' 设置为私有的。</Issue>
            </Message>
           </Messages>
          </Member>
         </Members>
        </Type>
       </Types>
      </Namespace>
     </Namespaces>
    </Module>
   </Modules>
  </Target>
 </Targets>
 <Rules>
  <Rule TypeName="AvoidUncalledPrivateCode" Category="Microsoft.Performance" CheckId="CA1811">
   <Name>避免使用未调用的私有代码</Name>
   <Description>存在对外部不可见的未调用代码，该代码不是已知的运行时入口点。如果错误地引发此冲突，请向 Visual Studio 代码分析团队发送问题报告。</Description>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182264.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Warning</MessageLevel>
   <File Name="performancerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DeclareEventHandlersCorrectly" Category="Microsoft.Design" CheckId="CA1009">
   <Name>正确声明事件处理程序</Name>
   <Description>按照约定，.NET 事件有两个参数，分别用于指定事件发送方和事件数据。事件处理程序签名应遵循以下形式: void MyEventHandler(object sender, EventArgs e)。“sender”参数的类型始终是 System.Object，即使该参数可能使用更具体的类型。“e”参数的类型始终是 System.EventArgs。不提供事件数据的事件应使用 System.EventHandler 委托类型。事件处理程序返回 void 以便将每个事件发送给多个目标方法。目标返回的任何值在第一次调用之后将会丢失。</Description>
   <Resolution Name="First">将 {0} 的第一个参数声明为一个名为“sender”的对象。</Resolution>
   <Resolution Name="Second">将 {0} 的第二个参数声明为 EventArgs，或者声明为扩展 EventArgs 的类型的名为“e”的实例。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182133.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DisposableTypesShouldDeclareFinalizer" Category="Microsoft.Usage" CheckId="CA2216">
   <Name>可释放类型应声明终结器</Name>
   <Description>如果某个类型实现 Dispose 方法并具有非托管资源，则它应当在没有显式调用 Dispose 的情况下提供 Finalize 方法。运行时在“垃圾回收”进程中回收对象的托管资源之前，先调用对象的 Finalize 方法或析构函数。Finalize 方法应在任何非托管资源变得不可访问之前释放它们。</Description>
   <Resolution Name="Default">针对 {0} 实现终结器或析构函数。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182329.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">Error</MessageLevel>
   <File Name="usagerules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotIndirectlyExposeMethodsWithLinkDemands" Category="Microsoft.Security" CheckId="CA2122">
   <Name>不要使用链接请求间接公开方法</Name>
   <Description>不要使用不执行安全性检查的方法来包装受 LinkDemand 保护的方法。LinkDemand 检查直接调用方的权限而不是调用堆栈中所有调用方的权限。在这种情况下，将检查包装器方法的权限。如果包装器方法本身不检查调用堆栈中位置较高的调用方的权限，则尽管恶意代码没有足够的权限，但它仍可能能够执行被包装的函数。</Description>
   <Resolution Name="Default">{0} 调入具有 LinkDemand 的 {1}。通过此调用，{1} 被间接公开给用户代码。检查以下可能公开避开安全保护的方法的调用堆栈: {2}</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182303.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="33">CriticalError</MessageLevel>
   <File Name="securityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="DoNotRaiseExceptionsInUnexpectedLocations" Category="Microsoft.Design" CheckId="CA1065">
   <Name>不要在意外的位置引发异常</Name>
   <Description>不要从意外的位置显式引发异常。用户不希望某些方法(如 Equals 和 GetHashCode)引发异常。因此，对这些方法的调用通常不包装在 try catch 块中。</Description>
   <Resolution Name="PropertyGetter">{0} 创建 {1} 类型的异常，该异常类型不应当在属性中引发。如果有可能会引发此异常实例，请使用其他异常类型，将该属性转换为方法，或者更改该属性的逻辑，使它不再引发异常。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/bb386039.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="90">Error, Warning</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="ImplementIDisposableCorrectly" Category="Microsoft.Design" CheckId="CA1063">
   <Name>正确实现 IDisposable</Name>
   <Description>所有 IDisposable 类型都应正确实现 Dispose 模式。</Description>
   <Resolution Name="DisposeImplementation">修改 {0}，使它先调用 Dispose(true)，然后对当前对象实例(在 Visual Basic 中为“this”或“Me”)调用 GC.SuppressFinalize，最后返回。</Resolution>
   <Resolution Name="ProvideDisposeBool">对 {0} 提供 Dispose(bool) 的可重写实现或将该类型标记为密封。对 Dispose(false) 的调用应仅清理本机资源。对 Dispose(true) 的调用应既清理托管资源又清理本机资源。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms244737.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="InterfaceMethodsShouldBeCallableByChildTypes" Category="Microsoft.Design" CheckId="CA1033">
   <Name>接口方法应可由子类型调用</Name>
   <Description>定义的显式方法实现具有私有可访问性。除非基类提供了具有相应可访问性的备用方法，否则从具有显式方法实现的类派生，并选择在类中重新声明它们的类不能调入基类实现。如果重写的基类方法已被显式接口实现所隐藏，则为了调入基类实现，派生类必须将基指针强制转换为相关接口。但是，通过此引用调用基类实现时，实际调用的将是派生类实现，这会导致递归调用，并最终导致堆栈溢出。</Description>
   <Resolution Name="Default">将 {0} 设置为密封(如果以前提供过此类，则为重大更改)，非显式实现该方法，或实现一个公开 {1} 的功能且对派生类可见的新方法。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182153.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="MovePInvokesToNativeMethodsClass" Category="Microsoft.Design" CheckId="CA1060">
   <Name>将 P/Invoke 移动到 NativeMethods 类</Name>
   <Description>此类型包含具有 DllImport 特性的成员。具有 DllImport 特性的成员应包含在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中。</Description>
   <Resolution Name="Default">由于是 P/Invoke 方法，因此，应在名为 NativeMethods、SafeNativeMethods 或 UnsafeNativeMethods 的类中定义 {0}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182161.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">CriticalWarning</MessageLevel>
   <File Name="designrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="OverrideLinkDemandsShouldBeIdenticalToBase" Category="Microsoft.Security" CheckId="CA2123">
   <Name>重写链接请求应与基相同</Name>
   <Description>在很多情况下，如果一个虚方法具有 LinkDemand，则它的任何重写方法都应具有 LinkDemand，同样，如果一个重写方法具有 LinkDemand，则被重写的虚方法也应具有 LinkDemand。由于调用方可能显式调用虚方法的任何重写方法，因此这些方法应具有相同的 LinkDemand 状态，否则应检查它们。由于调用方可能使用接口类型的引用来访问方法，因此上述规则也适用于对属于接口实现的方法进行的 LinkDemand 安全性检查。</Description>
   <Resolution Name="BaseOnly">向 {0} 添加下列安全特性以匹配基方法 {1} 上的 LinkDemand: {2}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182305(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="33">CriticalError</MessageLevel>
   <File Name="securitytransparencyrules.dll" Version="4.0.0.0" />
  </Rule>
  <Rule TypeName="PInvokeDeclarationsShouldBePortable" Category="Microsoft.Portability" CheckId="CA1901">
   <Name>P/Invoke 声明应为可移植声明</Name>
   <Description>.</Description>
   <Resolution Name="Parameter">如代码中所声明的，P/Invoke {1} 的参数 {0} 在 {3} 平台上的字节宽度将为 {2}。这是不正确的，因为此 API 的实际本机声明表明该参数在 {3} 平台上的字节宽度应为 {4}。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 {5}。</Resolution>
   <Resolution Name="Return">如代码中所声明的，P/Invoke {0} 的返回类型在 {2} 平台上的字节宽度将为 {1}。这是不正确的，因为此 API 的实际本机声明表明该返回类型在 {2} 平台上的字节宽度应为 {3}。请参考 MSDN Platform SDK 文档来获取帮助，确定应使用哪种数据类型来代替 {4}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182284(VS.100).aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="95">Error</MessageLevel>
   <File Name="portabilityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="PInvokeEntryPointsShouldExist" Category="Microsoft.Interoperability" CheckId="CA1400">
   <Name>P/Invoke 入口点应该存在</Name>
   <Description>使用 DLLImport 特性修饰的方法应指向现有的非托管入口点。任何编译时检查都无法确保那些使用 DLLImportAttribute 特性修饰的方法在所引用的非托管 dll 中实际存在。如果入口点不存在或指定的参数列表不正确，则会生成运行时异常。</Description>
   <Resolution Name="Default">更正 {0} 的声明，使它正确地指向 {1} 中的现有入口点。当前链接到的非托管入口点的名称是 {2}。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182208.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">CriticalWarning</MessageLevel>
   <File Name="interoperabilityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="PInvokesShouldNotBeVisible" Category="Microsoft.Interoperability" CheckId="CA1401">
   <Name>P/Invokes 应该是不可见的</Name>
   <Description>互操作层不应该是公共的。DllImport 特性不应该应用于可公开访问的成员(公共成员或受保护的成员)。</Description>
   <Resolution Name="Default">更改 P/Invoke {0} 的可访问性，使它在自己的程序集外部不再是可见的。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182209.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="50">CriticalError</MessageLevel>
   <File Name="interoperabilityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="PointersShouldNotBeVisible" Category="Microsoft.Security" CheckId="CA2111">
   <Name>指针应为不可见</Name>
   <Description>应将 IntPtr 和 UIntPtr 字段声明为私有。公开非私有指针可能会导致安全漏洞。</Description>
   <Resolution Name="Default">将 {0} 设置为私有的。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182306.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">CriticalError</MessageLevel>
   <File Name="securityrules.dll" Version="14.0.0.0" />
  </Rule>
  <Rule TypeName="SpecifyMarshalingForPInvokeStringArguments" Category="Microsoft.Globalization" CheckId="CA2101">
   <Name>指定对 P/Invoke 字符串参数进行封送处理</Name>
   <Description>在将字符串封送为 ANSI (在 Win9x 上为 Auto)时，某些字符可能会改变。如果启用了最佳匹配映射，则采用 Unicode 编码时显示样式不同的字符串将封送到相同的 ANSI 字符串，这可能会导致错误的安全决策。禁用最佳匹配映射会降低此风险，因为所有没有等效项的字符都将映射到“?”。另外，请注意，CharSet.Ansi 是所有字符串的默认封送设置；Unicode 封送必须显式指定为 DllImport 或 StructLayout 的 CharSet 设置，或者指定为具有 Unicode (或与系统相关的) UnmanagedType 的 MarshalAs 特性。</Description>
   <Resolution Name="Parameter">为了降低安全风险，请将参数 {0} 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode 或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或与系统相关的编码，请设置 BestFitMapping=false；为了提高安全性，还可以设置 ThrowOnUnmappableChar=true。</Resolution>
   <Resolution Name="ParameterImplicitAnsi">为了降低安全风险，请将参数 {0} 封送为 Unicode，方法是将 DllImport.CharSet 设置为 CharSet.Unicode，或者将该参数显式封送为 UnmanagedType.LPWStr。如果您需要将该字符串封送为 ANSI 或者与系统相关的编码，请显式指定 MarshalAs，并设置 BestFitMapping=false；为了提高安全性，还应设置 ThrowOnUnmappableChar=true。</Resolution>
   <Owner />
   <Url>http://msdn.microsoft.com/library/ms182319.aspx</Url>
   <Email>[none]</Email>
   <MessageLevel Certainty="75">Error</MessageLevel>
   <File Name="globalizationrules.dll" Version="14.0.0.0" />
  </Rule>
 </Rules>
 <Localized>
  <String Key="Category">类别</String>
  <String Key="Certainty">确定性</String>
  <String Key="CollapseAll">全部折叠</String>
  <String Key="CheckId">检查 ID</String>
  <String Key="Error">错误</String>
  <String Key="Errors">错误</String>
  <String Key="ExpandAll">全部展开</String>
  <String Key="Help">帮助</String>
  <String Key="Line">行</String>
  <String Key="Messages">消息</String>
  <String Key="LocationNotStoredInPdb">[位置未存储在 Pdb 中]</String>
  <String Key="Project">项目</String>
  <String Key="Resolution">解析</String>
  <String Key="Rule">规则</String>
  <String Key="RuleFile">规则文件</String>
  <String Key="RuleDescription">规则说明</String>
  <String Key="Source">源</String>
  <String Key="Status">状态</String>
  <String Key="Target">目标</String>
  <String Key="Warning">警告</String>
  <String Key="Warnings">警告</String>
  <String Key="ReportTitle">代码分析报告</String>
 </Localized>
</FxCopReport>
